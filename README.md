# 6

Имате дадени следните твърдения: 



Губим възможността за произволен достъп. Няма начин, по който да индексираме k-тия елемент, без да минем през всички k-1 предходни. [Динамична имплементация]
Реализация на списък чрез масив, който автоматично увеличава размера си при нужда. [Статична имплементация]
Операциите добавяне и премахване от вътрешността  на списъка изискват пренареждане на елементите. [Статична имплементация]
Операциите добавяне и премахване от вътрешността  на списъка е бърза операция. [Динамична имплементация]
Търсенето на елементите в него е сравнително бърза операция. [Статична имплементация]
При често добавяне и премахване (особено при голям брой елементи) това може да доведе до ниска производителност. [Статична имплементация]
Можем да поддържаме паметта точно колкото ни трябва като сложността на добавяне си остава. [Динамична имплементация]
Елементите съдържат само конкретния обект. [Статична имплементация]
Всеки елемент съдържа променлива и указател, сочещ към следващия елемент. [Динамична имплементация]

Вашата задача е да сравните и откриете кои от тези твърдения се отнасят за статична реализация на списък и кои за динамична реализация на списък. 



Избройте поне четири операции (методи), които можете да прилагате върху списък.

Add(T item)
Remove(T item)
RemoveAt(int index)
Sort()
ToArray()



Дайте пример с C# код, за метод който да сортира  елементите от списъка List<int> list = new List<int>() { 12, 8, 10, 2, 9, 6, 1}; посредством алгоритъма за сортиране  чрез метода на мехурчето.


 public static void BubbleSortWithFor(List<int> list)
        {
            for (int j = 0; j <= list.Count - 2; j++)
            {
                for (int i = 0; i <= list.Count - 2; i++)
                {
                    if (list[i] > list[i + 1])
                    {
                        Swap(list, i, i + 1);
                    }
                }
            }
        }
private static void Swap(List<int> list, int index, int min)
        {
            int temp = list[index];
            list[index] = list[min];
            list[min] = temp;
        }
  
  
 
  
  Допишете метода Add(object item) който трябва да добави елемент в списъка. Обърнете внимание, че първоначалния размер на масива може да бъде прехвърлен!


public void Add(T element)
        {
            if(this.Length == this.Capacity)
            {
                this.Capacity *= 2;
                T[] temp = new T[this.Capacity];
                for (int i = 0; i < items.Length; i++)
                {
                    temp[i] = items[i];
                }
                temp[this.Length] = element;
                items = temp;
                this.Length++;
            }
            else
            {
                items[this.Length] = element;
                this.Length++;
            }
        }
                                                 
                                                 
![image](https://github.com/arndv/6/assets/125039034/be30428a-d123-46f9-a929-2a6147697f32)
                                                 
